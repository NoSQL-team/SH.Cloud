noskool social network
======================
#### Общая структура:
![Main struct](https://github.com/NoSQL-team/noskool/raw/readme_images/img/main_struct.png)
___________________________________________________________________________________________
#### Фитчи:
* генерация ленты
* социальные отношения (друг — подписчик — никто)
* авторизация
* лайки постов
* комментарии постов

#### По структурно:
1. HTTP-server — принимает http-запросы от клиента, передаёт роутеру очередей
2. Queue router — делегирует запросы очередям (несколько очередей для уменьшения нагрузки на них, по сути инстансы одного класса)
3. Service queue — очередь сервера, то же инстансы одинаковые
4. Service auth — работает с токенами. Под его управлением БД с id всех пользователей и их токенами, если пользователь аутентифицирован, API:
    * Запрос аутентифицирован ли пользователь.
    * Запрос аутентификации по логину и паролю.
    * Запрос на выход из аккаунта
    * Запрос на добавление нового пользователя
Максимально простая схема, без системы двух токенов (access и refresh)
5. Service users — работает с данными пользователей. API:
    * Запрос на создание пользователя
        1. Создание его в БД
        2. Запрос auth сервиса на создание пользователя
    * Запрос на данные пользователя
    * Запрос всех пользователей
    * Запрос на удаление пользователя
        1. Запрос auth сервиса аутентифицирован ли пользователь
        2. Запрос в БД
    * Запрос на изменение данных пользователя
        1. Запрос auth сервиса аутентифицирован ли пользователь
        2. Запрос в БД
6. Service post — работает с постами. API:
    * Запрос постов для пользователя
        1. Запрос auth сервиса аутентифицирован ли пользователь
        2. Запрос auth сервиса получения id пользователя для выборки его друзей
        3. Запрос в friens сервис друзей пользователя
        4. Запрос в БД постов на основе выборки друзей
    * Запрос всех постов
    * Запрос постов пользователя
        1. Запрос в users сервис на id пользователя
        2. Запрос в БД постов
    * Запрос на создание поста
        1. Запрос auth сервиса аутентифицирован ли пользователь
        2. Запрос auth сервиса получения id пользователя для сохранения его в БД сервиса постов
        3. Запрос в БД на создание
    * Запрос на изменение поста
        1. Запрос auth сервиса аутентифицирован ли пользователь
        2. Запрос auth сервиса получения id пользователя для проверки его ли это пост
        3. Запрос на изменение поста в БД
    * Запрос на удаление поста
        1. Запрос auth сервиса аутентифицирован ли пользователь
        2. Запрос auth сервиса получения id пользователя для проверки его ли это пост
        3. Запрос на удаление поста в БД
    * Запрос определённого поста из БД
7) Service frends — работа с социальными отношениями между людьми. Данные в таблице хранятся по трёхбитовой системе (000 — никто, 100 — запрос дружбы отправлен от первого ко второму, 001 — запрос дружбы отправлен от второго к первому, 010 — друзья). Такое хранение позволяет одной записью описывать отношения между двумя пользователями. Можно было денормализировать БД и хранить друзей как строку id, но при большом количестве пользователей строки становятся слишком объёмными. API:
    1. Запрос на изменение отношения с другим пользователем
        1. Запрос auth сервиса аутентифицирован ли пользователь
        2. Запрос в БД на изменение
    2. Запрос на выборку друзей пользователя
        1. Запрос в users сервис на id пользователя
        2. Запрос в БД друзей

#### Протокол общения между серверами
```cpp
struct auth_token
{
    std::string token;
};

struct auth_with_login
{
    std::string login;
    std::string password;
};

// создание пользователя (поля для создания)
struct user_create
{
    /* data */
    std::string token;
};

// изменение данных о пользователе (изменяемые поля)
struct user_update
{
    /* data */
    std::string token;
};

// получение и удаление пользователя (никакие поля не нужны, кроме токена)
struct user
{
    std::string token;
};

// по аналогии с пользователми посты

template <class T>
struct request
{
    // номер сервера приложения    
    unsigned servie_number:8;
    // приоритетность запроса
    unsigned priority:1;
    // тип запроса
    unsigned req_type:3;
    // тело, в зависимости от сервера назначения меняется
    T req_body;
};

template <class T>
struct response
{
    // тело, в зависимости от сервера назначения меняется
    T resp_body;
};
```
Типы запросов:
* Создание сущности - 0
* Изменение сущности - 1
* Получение сущности - 2
* Удаление сущности - 3
* Проверка условия - 4

Приоритетность запросов:
высокий - 1
низкий - 0
Приоритетный запрос - запрос элементарный (не требующий обращений в другие сервисы). Задачи в сервисах выполняются в два потока (поток приоритетных задач и поток неприоритетных (комплексных) задач). Сделано для того, что бы комплексная задача не блокировала элементарные (так как комплексная ожидает ответа с других серверов). Также два потока исключают deadlock сервисов.

Неполадки на серверах можно «компенсировать» с помощью Null object pattern
__________________________________________________________________________
Полезные ссылки:
* MySQL for C/C++: [github + docs](https://github.com/mysql/mysql-connector-cpp)
* Программа для тестов http запросов (для того, кто http сервер делать будет): [сайт](https://www.postman.com/)
* Генератор JWT-токенов для аутентификации: [github](https://github.com/jpadilla/pyjwt)
* Про JWT: [habr](https://habr.com/ru/post/340146/)
